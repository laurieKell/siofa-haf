---
title: "CPUE Standardization for portuguese dogfish"
author: "Mariana"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, echo=TRUE, message=FALSE, warning=FALSE}
# Start with a clean environment
rm(list = ls())

# Load libraries
library(openxlsx)  # For reading Excel files
library(lubridate) # For handling date and time
library(dplyr)     # For data manipulation
library(ggplot2)   # For plotting
library(DHARMa)    # For residuals diagnostics
library(mgcv)      # For GAM models

```

## Data Preparation

```{r data-preparation}

df1 <- read.xlsx("../data/inputs/SIOFA_DWS-2023-01-Data.xlsx", sheet=2, startRow = 1, detectDates = TRUE, skipEmptyRows = TRUE)%>% 
    filter(speciesScientificName %in% "Centroscymnus coelolepis") #/ Filter species
  
# Adjust time format
adjust_time_format<-function(time)
    format(as.POSIXct(time * 86400, origin = "1970-01-01", tz = "UTC"), "%H:%M:%S")
  
df1$SettingTime=adjust_time_format(df1$SettingTime)
df1$HaulingTime=adjust_time_format(df1$HaulingTime)
df1$Time       =adjust_time_format(df1$Time)
  
# Extract year from date
df1$Year <- year(df1$Date)
  
# Calculate CPUE for the different gear types
df <- df1 %>% 
    mutate(CPUE = ifelse(Gear %in% c("Bottom trawls (nei)","Midwater trawls (nei)","Single boat bottom otter trawls","Trawls (nei)"),
                         catchWeight/(TowDuration_minutes/60),
                         ifelse(Gear %in% c("Gillnets and entangling nets (nei)"),
                                catchWeight/NetLength_m,
                                ifelse(Gear %in% c("Longlines (nei)","Vertical lines"),
                                       catchWeight/(Hooks_set/1000),
                                       ifelse(Gear %in% c("Set longlines"),
                                              catchWeight/(SoakTime_minutes/60),NA)))))
  
# Remove CPUE = NA
df <- df %>% filter(!is.na(CPUE))
  
# Remove negative soak time (Didn't work with filter)
idx <- which(df$SoakTime_minutes < 0)
df <- df[-idx,]
  
# Remove missing lon/lat -> this is 1 observation
df <- df %>% filter(!is.na(Longitude))

```

## Modelling 
I tried different models; The idea is to create a model like the following:
  Catch ~ Effort + Gear + Year
  
# Started with gamma glm

```{r gamma-glm}

m1 <- glm(catchWeight ~ CPUE + as.factor(Gear) + as.factor(Year), data = df, family = Gamma(link = "log"))
  
summary(m1)

#check residuals using dharma package
resm1 <- simulateResiduals(fittedModel = m1, n = 250)
plot(resm1) 
  
#check residuals
par(mfrow=c(2,2))
plot(m1)



```

# Trying a lognormal glm

```{r lognormal-glm}

df$logCatchWeight <- log(df$catchWeight)
m2 <- glm(logCatchWeight ~ CPUE + as.factor(Gear) + as.factor(Year), data = df, family = gaussian(link = "identity"))

summary(m2)
drop1(m2, test = "Chisq")
resm2 <- simulateResiduals(fittedModel = m2, n = 250)
plot(resm2)

#check residuals
par(mfrow=c(2,2))
plot(m2)

```

# gamma GAM

```{r gamma-GAM}

m3 <- gam(catchWeight ~ s(CPUE) + as.factor(Gear) + as.factor(Year), data = df, family = Gamma(link = "log"))

summary(m3)
resm3 <- simulateResiduals(fittedModel = m3, n = 250)
plot(resm3) 

#check residuals
plot(m3)
gam.check(m3)

```

# gaussian GAM

```{r gaussian-GAM}

m4 <- gam(catchWeight ~ s(CPUE) + s(Year) + as.factor(Gear), data = df, family = gaussian())

summary(m4)
resm4 <- simulateResiduals(fittedModel = m4, n = 250)
plot(resm4) 

#check residuals
plot(m4)
gam.check(m4)

```

# lognormal GAM

```{r lognormal-GAM}

m5 <- gam(logCatchWeight ~ s(CPUE) + s(Year) + as.factor(Gear), data = df, family = gaussian())

summary(m5)
resm5 <- simulateResiduals(fittedModel = m5, n = 250)
plot(resm5) 

#check residuals
plot(m5)
gam.check(m5)

```

# Comparing AIC between models

```{r AIC}

AIC(m1, m2, m3, m4, m5)

#m5 with lowest AIC folled by m2

```

# Getting Index and CVs for both m5 (lognormal GAM) and m2 (lognormal glm)


```{r Index-CVs}

#Starting with m5 - lognormal GAM

predict_m5 <- predict.gam(m5, type="response")
predict_orig_m5 <- exp(predict_m5)
yearly_index_m5 <- tapply(predict_orig_m5, df$Year, mean)

cv_per_year_m5 <- tapply(predict_orig_m5, df$Year, function(x) {  
  cv <- sd(x) / mean(x) * 100
  return(cv)})

yearly_index_df_m5 <- data.frame(Year = names(yearly_index_m5), Index = yearly_index_m5)
cv_per_year_df_m5 <- data.frame(Year = names(cv_per_year_m5), CV = cv_per_year_m5)

df_index_m5 <- merge(yearly_index_df_m5, cv_per_year_df_m5)

ggplot(data=df_index_m5, aes(x=Year, y= Index, group = 1)) + geom_line()

ggplot(data = df_index_m5, aes(x = Year, y = Index, group = 1)) + geom_line() + geom_point() + geom_errorbar(aes(ymin = Index - CV, ymax = Index + CV),width = 0.2)


#m2 - lognormal glm

predict_m2 <- predict.glm (m2, type="response")
predict_orig_m2 <- exp(predict_m2)
yearly_index_m2 <- tapply(predict_orig_m2, df$Year, mean)

cv_per_year_m2 <- tapply(predict_orig_m2, df$Year, function(x) {  
  cv <- sd(x) / mean(x) * 100
  return(cv)})

yearly_index_df_m2 <- data.frame(Year = names(yearly_index_m2), Index = yearly_index_m2)
cv_per_year_df_m2 <- data.frame(Year = names(cv_per_year_m2), CV = cv_per_year_m2)

df_index_m2 <- merge(yearly_index_df_m2, cv_per_year_df_m2)

ggplot(data=df_index_m2, aes(x=Year, y= Index, group = 1)) + geom_line()

#2017 seems to be an outlier:

df_index_m2 <- df_index_m2 %>% 
              mutate(Index = ifelse(Year %in% 2017, 0, Index))

ggplot(data = df_index_m2, aes(x = Year, y = Index, group = 1)) + geom_line() + geom_point() + geom_errorbar(aes(ymin = Index - CV, ymax = Index + CV),width = 0.2)

ggplot(data = df_index_m2, aes(x = Year, y = Index, group = 1)) +
  geom_line() +  # Connect points across years
  geom_point() +
  geom_ribbon(aes(ymin = Index - CV, ymax = Index + CV), alpha = 0.2) +
  geom_errorbar(aes(ymin = Index - CV, ymax = Index + CV), width = 0.2)


```


# Relashionship between gear and depth

```{r Depth-Gear}

depth <- df %>% filter(!is.na(Depth))

ggplot(df, aes(x = Gear, y = Depth)) + geom_boxplot()

anova_result <- aov(Depth ~ as.factor(Gear), data = df)
summary(anova_result)
TukeyHSD(anova_result)
kruskal.test(Depth ~ Gear, data = df)

#results indicate a strong association between gear types and the depths at which they operate

```

